import { attachComponentData, createApiRef, useElementFilter, useApi } from '@backstage/core-plugin-api';
import { createVersionedContext, createVersionedValueMap, getOrCreateGlobalSingleton } from '@backstage/version-bridge';
import React, { useState, useContext, useCallback, useEffect } from 'react';
import { useImmerReducer } from 'use-immer';

const FIELD_EXTENSION_WRAPPER_KEY = "scaffolder.extensions.wrapper.v1";
const FIELD_EXTENSION_KEY = "scaffolder.extensions.field.v1";

function createScaffolderFieldExtension(options) {
  return {
    expose() {
      const FieldExtensionDataHolder = () => null;
      attachComponentData(
        FieldExtensionDataHolder,
        FIELD_EXTENSION_KEY,
        options
      );
      return FieldExtensionDataHolder;
    }
  };
}
const ScaffolderFieldExtensions = () => null;
attachComponentData(
  ScaffolderFieldExtensions,
  FIELD_EXTENSION_WRAPPER_KEY,
  true
);

const SecretsContext = createVersionedContext("secrets-context");
const SecretsContextProvider = (props) => {
  const [secrets, setSecrets] = useState({});
  return /* @__PURE__ */ React.createElement(
    SecretsContext.Provider,
    {
      value: createVersionedValueMap({ 1: { secrets, setSecrets } })
    },
    props.children
  );
};
const useTemplateSecrets = () => {
  var _a;
  const value = (_a = useContext(SecretsContext)) == null ? void 0 : _a.atVersion(1);
  if (!value) {
    throw new Error(
      "useTemplateSecrets must be used within a SecretsContextProvider"
    );
  }
  const { setSecrets: updateSecrets, secrets = {} } = value;
  const setSecrets = useCallback(
    (input) => {
      updateSecrets((currentSecrets) => ({ ...currentSecrets, ...input }));
    },
    [updateSecrets]
  );
  return { setSecrets, secrets };
};

const scaffolderApiRef = getOrCreateGlobalSingleton(
  "scaffolder:scaffolder-api-ref",
  () => createApiRef({
    id: "plugin.scaffolder.service"
  })
);

const useCustomFieldExtensions = (outlet) => {
  return useElementFilter(
    outlet,
    (elements) => elements.selectByComponentData({
      key: FIELD_EXTENSION_WRAPPER_KEY
    }).findComponentData({
      key: FIELD_EXTENSION_KEY
    })
  );
};

const LAYOUTS_KEY = "scaffolder.layout.v1";
const LAYOUTS_WRAPPER_KEY = "scaffolder.layouts.wrapper.v1";

const useCustomLayouts = (outlet) => {
  return useElementFilter(
    outlet,
    (elements) => elements.selectByComponentData({
      key: LAYOUTS_WRAPPER_KEY
    }).findComponentData({
      key: LAYOUTS_KEY
    })
  );
};

function reducer(draft, action) {
  var _a, _b, _c;
  switch (action.type) {
    case "INIT": {
      draft.steps = action.data.spec.steps.reduce((current, next) => {
        current[next.id] = { status: "open", id: next.id };
        return current;
      }, {});
      draft.stepLogs = action.data.spec.steps.reduce((current, next) => {
        current[next.id] = [];
        return current;
      }, {});
      draft.loading = false;
      draft.error = void 0;
      draft.completed = false;
      draft.task = action.data;
      return;
    }
    case "LOGS": {
      const entries = action.data;
      for (const entry of entries) {
        const logLine = `${entry.createdAt} ${entry.body.message}`;
        if (!entry.body.stepId || !((_a = draft.steps) == null ? void 0 : _a[entry.body.stepId])) {
          continue;
        }
        const currentStepLog = (_b = draft.stepLogs) == null ? void 0 : _b[entry.body.stepId];
        const currentStep = (_c = draft.steps) == null ? void 0 : _c[entry.body.stepId];
        if (entry.body.status && entry.body.status !== currentStep.status) {
          currentStep.status = entry.body.status;
          if (currentStep.status === "processing") {
            currentStep.startedAt = entry.createdAt;
          }
          if (["cancelled", "failed", "completed"].includes(currentStep.status)) {
            currentStep.endedAt = entry.createdAt;
          }
        }
        currentStepLog == null ? void 0 : currentStepLog.push(logLine);
      }
      return;
    }
    case "COMPLETED": {
      draft.completed = true;
      draft.output = action.data.body.output;
      draft.error = action.data.body.error;
      return;
    }
    case "ERROR": {
      draft.error = action.data;
      draft.loading = false;
      draft.completed = true;
      return;
    }
    default:
      return;
  }
}
const useTaskEventStream = (taskId) => {
  const scaffolderApi = useApi(scaffolderApiRef);
  const [state, dispatch] = useImmerReducer(reducer, {
    loading: true,
    completed: false,
    stepLogs: {},
    steps: {}
  });
  useEffect(() => {
    let didCancel = false;
    let subscription;
    let logPusher;
    scaffolderApi.getTask(taskId).then(
      (task) => {
        if (didCancel) {
          return;
        }
        dispatch({ type: "INIT", data: task });
        const observable = scaffolderApi.streamLogs({ taskId });
        const collectedLogEvents = new Array();
        function emitLogs() {
          if (collectedLogEvents.length) {
            const logs = collectedLogEvents.splice(
              0,
              collectedLogEvents.length
            );
            dispatch({ type: "LOGS", data: logs });
          }
        }
        logPusher = setInterval(emitLogs, 500);
        subscription = observable.subscribe({
          next: (event) => {
            switch (event.type) {
              case "log":
                return collectedLogEvents.push(event);
              case "completion":
                emitLogs();
                dispatch({ type: "COMPLETED", data: event });
                return void 0;
              default:
                throw new Error(
                  `Unhandled event type ${event.type} in observer`
                );
            }
          },
          error: (error) => {
            emitLogs();
            dispatch({ type: "ERROR", data: error });
          }
        });
      },
      (error) => {
        if (!didCancel) {
          dispatch({ type: "ERROR", data: error });
        }
      }
    );
    return () => {
      didCancel = true;
      if (subscription) {
        subscription.unsubscribe();
      }
      if (logPusher) {
        clearInterval(logPusher);
      }
    };
  }, [scaffolderApi, dispatch, taskId]);
  return state;
};

function createScaffolderLayout(options) {
  return {
    expose() {
      const LayoutDataHolder = () => null;
      attachComponentData(LayoutDataHolder, LAYOUTS_KEY, options);
      return LayoutDataHolder;
    }
  };
}
const ScaffolderLayouts = () => null;
attachComponentData(ScaffolderLayouts, LAYOUTS_WRAPPER_KEY, true);

export { ScaffolderFieldExtensions, ScaffolderLayouts, SecretsContextProvider, createScaffolderFieldExtension, createScaffolderLayout, scaffolderApiRef, useCustomFieldExtensions, useCustomLayouts, useTaskEventStream, useTemplateSecrets };
//# sourceMappingURL=index.esm.js.map
